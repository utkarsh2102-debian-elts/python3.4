From c50d437e942d4c4c45c8cd76329b05340c02eb31 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Miro=20Hron=C4=8Dok?= <miro@hroncok.cz>
Date: Wed, 8 May 2019 18:33:24 +0200
Subject: [PATCH] bpo-30458: Disallow control chars in http URLs. (GH-12755)
 (GH-13155)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Disallow control chars in http URLs in urllib.urlopen.  This addresses a potential security problem for applications that do not sanity check their URLs where http request headers could be injected.

Disable https related urllib tests on a build without ssl (GH-13032)
These tests require an SSL enabled build. Skip these tests when python is built without SSL to fix test failures.

Use http.client.InvalidURL instead of ValueError as the new error case's exception. (GH-13044)

Co-Authored-By: Miro Hronƒçok <miro@hroncok.cz>
---
 Lib/http/client.py                            | 15 ++++++
 Lib/test/test_urllib.py                       | 53 +++++++++++++++++++
 Lib/test/test_xmlrpc.py                       |  7 ++-
 .../2019-04-10-08-53-30.bpo-30458.51E-DA.rst  |  1 +
 4 files changed, 75 insertions(+), 1 deletion(-)
 create mode 100644 Misc/NEWS.d/next/Security/2019-04-10-08-53-30.bpo-30458.51E-DA.rst

--- python3.4-jessie.git.orig/Lib/http/client.py
+++ python3.4-jessie.git/Lib/http/client.py
@@ -244,6 +244,16 @@
 _is_legal_header_name = re.compile(rb'[^:\s][^:\r\n]*').fullmatch
 _is_illegal_header_value = re.compile(rb'\n(?![ \t])|\r(?![ \t\n])').search
 
+# These characters are not allowed within HTTP URL paths.
+#  See https://tools.ietf.org/html/rfc3986#section-3.3 and the
+#  https://tools.ietf.org/html/rfc3986#appendix-A pchar definition.
+# Prevents CVE-2019-9740.  Includes control characters such as \r\n.
+# We don't restrict chars above \x7f as putrequest() limits us to ASCII.
+_contains_disallowed_url_pchar_re = re.compile('[\x00-\x20\x7f]')
+# Arguably only these _should_ allowed:
+#  _is_allowed_url_pchars_re = re.compile(r"^[/!$&'()*+,;=:@%a-zA-Z0-9._~-]+$")
+# We are more lenient for assumed real world compatibility purposes.
+
 
 class HTTPMessage(email.message.Message):
     # XXX The only usage of this method is in
@@ -998,6 +1008,11 @@
         self._method = method
         if not url:
             url = '/'
+        # Prevent CVE-2019-9740.
+        match = _contains_disallowed_url_pchar_re.search(url)
+        if match:
+            raise InvalidURL("URL can't contain control characters. {!r} "
+                             "(found at least {!r})".format(url, match.group()))
         request = '%s %s %s' % (method, url, self._http_vsn_str)
 
         # Non-ASCII characters should have been eliminated earlier
--- python3.4-jessie.git.orig/Lib/test/test_urllib.py
+++ python3.4-jessie.git/Lib/test/test_urllib.py
@@ -10,6 +10,10 @@ import unittest
 from unittest.mock import patch
 from test import support
 import os
+try:
+    import ssl
+except ImportError:
+    ssl = None
 import sys
 import tempfile
 from nturl2path import url2pathname, pathname2url
@@ -253,6 +253,33 @@ class urlopen_HttpTests(unittest.TestCase, FakeHTTPMixin, FakeFTPMixin):
         finally:
             self.unfakehttp()
 
+    @unittest.skipUnless(ssl, "ssl module required")
+    def test_url_with_control_char_rejected(self):
+        for char_no in list(range(0, 0xa)) + list(range(0xb, 0x21)) + [0x7f]:
+            char = chr(char_no)
+            schemeless_url = "//localhost:7777/test{}/".format(char)
+            self.fakehttp(b"HTTP/1.1 200 OK\r\n\r\nHello.")
+            try:
+                # We explicitly test urllib.request.urlopen() instead of the top
+                # level 'def urlopen()' function defined in this... (quite ugly)
+                # test suite.  They use different url opening codepaths.  Plain
+                # urlopen uses FancyURLOpener which goes via a codepath that
+                # calls urllib.parse.quote() on the URL which makes all of the
+                # above attempts at injection within the url _path_ safe.
+                escaped_char_repr = repr(char).replace('\\', r'\\')
+                InvalidURL = http.client.InvalidURL
+                with self.assertRaisesRegex(
+                    InvalidURL, "contain control.*{}".format(escaped_char_repr)):
+                    urllib.request.urlopen("http:{}".format(schemeless_url))
+                with self.assertRaisesRegex(
+                    InvalidURL, "contain control.*{}".format(escaped_char_repr)):
+                    urllib.request.urlopen("https:{}".format(schemeless_url))
+                # This code path quotes the URL so there is no injection.
+                resp = urlopen("http:{}".format(schemeless_url))
+                self.assertNotIn(char, resp.geturl())
+            finally:
+                self.unfakehttp()
+
     def test_read_0_9(self):
         # "0.9" response accepted (but not "simple responses" without
         # a status line)
--- python3.4-jessie.git.orig/Lib/test/test_xmlrpc.py
+++ python3.4-jessie.git/Lib/test/test_xmlrpc.py
@@ -710,7 +710,12 @@
     def test_partial_post(self):
         # Check that a partial POST doesn't make the server loop: issue #14001.
         conn = http.client.HTTPConnection(ADDR, PORT)
-        conn.request('POST', '/RPC2 HTTP/1.0\r\nContent-Length: 100\r\n\r\nbye')
+        conn.send('POST /RPC2 HTTP/1.0\r\n'
+                  'Content-Length: 100\r\n\r\n'
+                  'bye HTTP/1.1\r\n'
+                  'Host: {}:{}\r\n'
+                  'Accept-Encoding: identity\r\n'
+                  'Content-Length: 0\r\n\r\n'.format(ADDR,PORT).encode('ascii'))
         conn.close()
 
 
--- /dev/null
+++ python3.4-jessie.git/Misc/NEWS.d/next/Security/2019-04-10-08-53-30.bpo-30458.51E-DA.rst
@@ -0,0 +1 @@
+Address CVE-2019-9740 by disallowing URL paths with embedded whitespace or control characters through into the underlying http client request.  Such potentially malicious header injection URLs now cause an http.client.InvalidURL exception to be raised.
